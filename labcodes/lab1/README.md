1. How make generate ucore.img? See code comments

2. What is master boot record layout?
* When attempting to boot from a hard drive, the BIOS tries to find a boot sector. 
* On hard drives partitioned with an MBR partition layout, the boot sector is stored in the first 446 bytes of the first sector, where each sector is 512 bytes. 
* The final two bytes of the first sector are 0x55 and 0xaa, which designates to the BIOS that this device is bootable.
3. Process of debugging using QEMU and gdb
* make debug -- run PHONY recipe in Makefile. Use x /2i 0xffff0 and x /10i 0xfe05b to print the assembly code.
* /etc/gdb/gdbinit stores the global config of gdb, add config there to enforce showing the assembly code (by reverse compilation?). 
* add Use b *0x7c00 to set up breakpoint at address 0x7c00, after that use ni to step-run the code. Check code generated by gdb and find it's similar with what's in boot/bootasm.S and obj/boot/bootblock.asm
* 0xffff0(A20 is turned off) is where BIOS code starts; 0x7c00 is where the bootasm code starts. 
4. Analyze how bootloader enable protection mode
* GDT is initialized at bootloader; IDT is initialized in uCore.
* why open A20? Physical address line 20 is disabled/tied low, so that address higher than 1MB is wrapped around to zero by default, for backward compatibility with earliest PCs. Earliest 8086 CPU provides 20 address line. 2^20 = 1MB memory.
* how to open A20? Read content of status register from 0x64. Write command to 0x64. inb $0x64, %al to read status to al register. testb $0x2, %al actually executed 0x02 AND al, if the 1st bit(0-based) of %al is 1, which indicates the Input buffer status (0 = empty, 1 = full), ZF is set to 0. next, jnz will jump to seta20.1 again if ZF = 0 in this case, which means input buffer is not empty. 
Now we jump out of the seta20.1 loop, input buffer is empty. We write oxD1 command to port 0x64. 0xD1 means writing data to 8042's P2 port.
seta20.2 is started from the same loop. After making sure input buffer is empty, we can write data to 0xDF as data into 0x60. 0xDF is 11011111, which sets P2's A20 bit to be 1.
* How to initialize GDT? lgdt is used to load GDT LIMIT and ADDRESS into GDT register, whose lower 16 bits tell the size of GDT and upper 32 bits tell the locatoin of GDT in memory. So we will know that 0x17 is sizeOf(gdt) - 1 and gdt address starts from <.long gdt> in L102.
In GDT, there're 3 descriptors, and each one take 8 bytes. The 1st is NULL descriptor, indicating the start of GDT. The following is code segment descriptor(the code segment starts from 0, size if 4GB, with STA_R and STA_X permission. The last is data segment with same start and size, with STA_R and STA_W permission.
* How to enter protection mode?
Then cr0 PE bit(the 1st bit) is set to be 1 to enable protection mode.
The functionality of CS segment register is largely changed after entering protection mode. Before that, CS serves as a base address(CS * 16 + IP). After that, it is a segment selector, which's used as an index of GDT. ljmp must be executed right after mov, to change CS register to the selector. 
ljmp $PROT_MODE_CSEG, $protcseg will assign segment selector(0x08, which index to the 2nd descriptor of GDT mentioned above) to code segment register and assign $protcseg(offset, understand it as the code block start, which is added to base address) for EIP.
Now we can execute the assembly code indicated by $protcseg, which sets up protect-mode data segment registers.
Finally, initialize %ebp to be 0 and set stack pointer %esp to be start(0x7c00) and call into C(bootmain). 
